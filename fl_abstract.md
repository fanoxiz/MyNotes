---
title: "Дискретный анализ, 2025"
author: "@witzberg"
date: "2026-01-09"
---

## 1. Недетерминированные конечные автоматы (НКА). Различные варианты определений. Автоматные языки: примеры автоматных языков.

**Алфавит -** непустое конечное множество $\Sigma$

**Слово -** конечная последовательность элементов алфавита

**Формальный язык -** $L \subset \Sigma^*$  

**НКА -** кортеж $(\Sigma, Q, \Delta, q_0, F)$, где:

- $\Sigma$ - конечное множество букв (алфавит)
- $Q$ - конечное множество состояний
- $\Delta \subset Q \times \Sigma^* \times Q$. Переход записывается как:  
  $$ (q, w) \to q' $$
- $q_0 \in Q$ - начальное состояние
- $F \subset Q$ - множество завершающих состояний

**Конфигурация -** пара $(q, w) \in S \subset Q \times \Sigma^*$, где $q \in Q$ - текущее состояние, $w \in \Sigma^*$ - недочитанный суффикс слова

**Отношение выводимости $\vdash$ (штопора) -** такое что $\forall u \in \Sigma^*$:  
$$ (q_1, w) \to q_2 \in \Delta \iff (q_1, wu) \vdash (q_2, u) $$

**Замыкание $\vdash^*$ -** наименьшее рефлексивное транзитивное отношение, содержащее $\vdash$

**Автоматный язык -** такое множество слов $L$, что:  
$$ L(M) = \{w \mid \exists q_f \in F, (q_0, w) \vdash^* (q_f, \varepsilon)\} $$

**Эпсилон замыкание -** $\text{Closure}(q) = \{p \in Q \mid (q, \varepsilon) \vdash^* (p, \varepsilon) \}$

> **Различные варианты определений НКА**  
> Класс автоматных языков не меняется при наложении следующих ограничений на НКА:
> 1. $|F| = 1$
> 2. $\forall ((q, w) \to q'): \ |w| \le 1$
> 3. $\forall ((q, w) \to q'): \ |w| = 1$

$\triangle$  
1. $M = (\Sigma, Q', \Delta', q_0, \{q_Z \})$, где $Q' = Q \cup \{q_Z \}, \Delta' = \Delta \cup F \times \{\varepsilon \} \times \{q_Z \}$
2. Добавляем новые состояния, разбивая переходы по словам длины больше $1$.
3. Как в билете [2](#2-детерминированные-конечные-автоматы-дка-эквивалентность-дка-и-нка)

## 2. Детерминированные конечные автоматы (ДКА). Эквивалентность ДКА и НКА.

**ДКА -** такой НКА, что все переходы однобуквенные и $\forall q \in Q \ \forall a \in \Sigma: \big| \{ q' \in Q \mid ((q, a) \to q') \in \Delta \} \big| \le 1$

**ПДКА -** тот ДКА, что для каждой пары $(q, a)$ такой переход существует

> **Эквивалентность ДКА и НКА**  
> Для всякого НКА с однобуквенными переходами $M = (\Sigma, Q, \Delta, q_0, F)$ существует ДКА $M' = (\Sigma, 2^Q, \Delta', \{q_0\}, F')$, что $L(M) = L(M')$

$\triangle$  
Предьявим алгоритм построения (У нас его назвали *Алгоритмом Томпсона*, хотя это не так). Далее подразумевается, что эпсилон переходы удалены из НКА  

- Поместить множество $q'_0 = \text{Closure}(q_0)$ в очередь.
- Пока очередь не пуста:
    - Извлечь множество состояний $A$.
    - Для каждой буквы $z \in \Sigma$:
        - Найти множество $B = \{b \in Q \mid \exists q \in A: ((q, z) \to b) \in \Delta \}$
        - Если $U = \text{Closure}(B)$ - новое состояние, добавить его очередь и в множество состояний ДКА.
        - Добавить переход $A \xrightarrow{z} U$ в ДКА.
- Отметить завершающими те множества, которые содержат хотя бы одно завершающее состояние исходного НКА.

### Асимптотика
Т.к. $|Q'| = O(2^{|Q|})$ в худшем случае, то асимптотика $O(|\Sigma| \cdot |Q| \cdot 2^{|Q|})$


## 3. Свойства класса автоматных языков. Замкнутость относительно булевых операций.

**Класс языков $\mathcal{A}$ замкнут относительно операции $*$, если**
$$ \forall L_1, L_2 \in \mathcal{A}: L_1 * L_2 \in \mathcal{A} $$
*\*Аналогично для унарных операций*

> **Теорема о замкнутости $\mathbf{REG}$ языков**  
> Класс автоматных языков замкнут относительно:
> - Объединения
> - Конкатенации
> - Дополнения
> - Пересечения
> - Разности
> - Итерация Клини

$\triangle$  
- **Объединение, Конкатенация**  
  Параллельно или последовательно устанавливаем автоматы

- **Дополнение**  
  Если $L$ задан полным **(!)** ДКА $M = (\Sigma, Q, \Delta, q_0, F)$, то $\overline{L} = \Sigma^* \setminus L$ задается ДКА $\overline{M} = (\Sigma, Q, \Delta, q_0, Q \setminus F)$

- **Пересечение**  
  Следует из законов де Моргана: $L_1 \cap L_2 = \overline{\overline{L_1} \cup \overline{L_2}}$.
  Альтернативно: строим декартово произведение $Q_1 \times Q_2$, завершающие те, где оба в паре завершающие, и т.д.

- **Разность**  
  $L_1 \setminus L_2 = L_1 \cap \overline{L_2}$

- **Итерация Клини**  
  Добавляем новое стартовое состояние, оно также завершающее. Переходы по эпсилону в старое стартовое, и из всех завершающих в новое стартовое

## 4. Регулярные выражения. Теорема Клини. Регулярный автомат. Алгоритм построения РВ по автомату.

**Регулярное выражение (РВ) -** конечная последовательность над алфавитом $\Sigma \cup \{+, ^*, \cdot, 0, 1\}$, определяемая индуктивно:
- $0, 1, a \in \Sigma$ - РВ
- $\alpha + \beta$, $\alpha\beta$, $\alpha^*$ - РВ

**Язык, задаваемый РВ -** определяется индуктивно:
- $L(0) = \varnothing$
- $L(1) = \{\varepsilon \}$
- $L(a) = \{a \}$
- $L(a \cdot b) = L(a) \cdot L(b)$
- $L(a + b) = L(a) \cup L(b)$
- $L(a^*) = (L(a))^*$

**Регулярный автомат -** НКА, где переходы не по буквам, а по РВ

> **Теорема Клини $(\mathbf{AUT = REG})$**  
> Класс языков, распознаваемый НКА, и языков, задаваемых регулярными выражениями, совпадают

$\triangle$  
Предьявим алгоритм построения РВ по НКА.  
Делаем одно завершающее и добавляем начальное $q'_0$, с переходом $(q'_0, \varepsilon) \to q_0$. Удаляем цепи. Начинаем исключать состояния:
- Выбираем состояние $q_{rem} \in Q \setminus \{q_{start}, q_{fin}\}$. Рассматриваем все пары состояний $(q_{in}, q_{out})$, таких что есть переходы $q_{in} \to q_{rem}$ и $q_{rem} \to q_{out}$  
Пусть:
  - $r_{ir}$ - РВ на ребре $q_{in} \to q_{rem}$
  - $r_{rr}$ - РВ на петле $q_{rem} \to q_{rem}$ (если петли нет, то $r_{rr} = 0$)
  - $r_{ro}$ - РВ на ребре $q_{rem} \to q_{out}$
  - $r_{io}$ - РВ прямого перехода $q_{in} \to q_{out}$

  Тогда обновляем переход $q_{in} \to q_{out}$ новым выражением:
    $$ r_{new} = r_{io} + r_{ir} (r_{rr})^* r_{ro} $$
- Удаляем состояние $q_{rem}$ и инцидентные ему ребра

Когда останутся $2$ состояния, РВ на переходе между ними - искомое


## 5. Эквивалентность состояний в ПДКА. Эквивалентность слов по языку. Оценка на минимальное количество состояний в ПДКА.

**Эквивалентность состояний по автомату -**
$$ q_1 \sim_M q_2 \iff \forall u \in \Sigma^*: (\delta(q_1, u) \in F \iff \delta(q_2, u) \in F) $$

**Эквивалентность слов по языку -**
$$ w \sim_L v \iff \forall u \in \Sigma^*: (wu \in L \iff vu \in L) $$

> **Оценка на минимальное количество состояний в ПДКА**  
> Для любого ПДКА, задающего язык $L$:
> $$ |Q| \ge |\Sigma^* / \sim_L| $$

$\triangle$  
Если два слова $u$ и $v$ переводят автомат в одно и то же состояние из $q_0$, то они ведут себя одинаково для любого суффикса, т.е. эквивалентны по языку. Если состояний меньше, чем классов эквивалентности, то по принципу Дирихле найдутся два слова из разных классов эквивалентности, которые придут в одно состояние, но тогда они должны быть эквивалентны. Противоречие.


## 6. Критерий минимальности количества состояний в ПДКА.

**МПДКА -** ПДКА, имеющий наименьшее возможное число состояний среди всех ПДКА, распознающих данный язык.

> **Критерий минимальности ПДКА**  
> $$ M \text{ - минимальный ПДКА} \iff |Q| = |\Sigma^* / \sim_L| $$
*\*Альтернативно, все состояния попарно неэквивалентны и достижимы из стартового*


## 7. Канонический ПДКА - корректность построения. Единственность МПДКА.

**Канонический МПДКА -** МПДКА на классах эквивалентности:
- $Q = \Sigma^* / \sim_L$ (состояния - классы эквивалентности слов)
- $q_0 = [\varepsilon]_L$
- $F = \{ [u]_L \mid u \in L \}$
- $\Delta = \{ ([u]_L, a) \to [ua]_L \}$

> **Корректность канонического ПДКА**  
> Канонический автомат, построенный по регулярному языку $L$, корректно определен, распознает язык $L$ и является минимальным (МПДКА).

> **Единственность МПДКА**  
> МПДКА для языка единственен с точностью до изоморфизма

**Канонический изоморфизм -** изоморфизм между состояниями МПДКА и классами эквивалентности по языку


## 8. Алгоритм проверки равенства РВ без построения МПДКА. Алгоритм проверки МПДКА на эквивалентность. Теорема Майхилла–Нероуда.

> **Проверка равенства РВ без МПДКА**  

$\triangle$  
По РВ строим НКА, затем ПДКА. Обьединяем два ПДКА в один несвязный. То есть просто $Q' = Q_1 \cup Q_2$. Запускаем по нему алгоритм Мура разбиения состояний на классы эквивалентности (см. билет [10](#10-алгоритм-минимизации-дка)). РВ равны $\iff$ $q_0$ обоих автоматов в одном классе эквивалентности по автомату

> **Алгоритм проверки МПДКА на эквивалентность**  

$\triangle$  
Запускаем обход по декартовому произведению автоматов из пары $(q^1_0, q^2_0)$, то есть $((u, v), a) \to (\delta(u, a), \delta(v, a))$. Оба состояния в паре должны иметь один тип

> **Теорема Майхилла–Нероуда**  
> $L \in \mathbf{AUT} \iff |\Sigma^* / \sim_L| \lt \infty$ 

$\triangle$  
$L \in \mathbf{AUT} \iff \exists$ канонический МПДКА $\iff$ классов эквивалентности конечно

## 9. Лемма о накачке для автоматных языков. Примеры неавтоматных языков.

> **Лемма о накачке для $\mathbf{AUT}$ языков**  
> Если $L$ - автоматный язык, то $\exists p \in \mathbb{N}$, что $\forall w \in L, |w| \ge p$, $\exists$ разбиение $w = xyz, |y| \gt 0, |xy| \le p$, что:  
> $$ \forall k \ge 0: xy^kz \in L $$

$\triangle$  
Положим $p$ равное количеству классов эквивалентности по данному языку. Для слов длиннее $p$, по Дирихле, какое-то состояние в МПДКА повторится. Цикл между повторениями этого состояния будет $y$. Его можно вырезать, или наоборот дублировать сколько угодно раз.

> **Отрицание леммы**  
> Нужно для любого $p$ найти слово, что для любого разбиения этого слова найдется $k$, при котором "накаченное" $w_k \notin L$

**Примеры неавтоматных языков и $w$ для Леммы**
- $L = \{ a^n b^n \mid n \ge 1 \}$  
  Берем $w = a^p b^p$
- $L = \{ w \in \{a, b \}^* \mid w = w^R \}$ - палиндромы  
  Берем $w = a^p b a^p$


## 10. Алгоритм минимизации ДКА.

> **Алгоритм Мура разбиения ДКА на классы эквивалентности (т.е. приведение ДКА к минимальному)**  

Вначала выделяем только $2$ группы всех состояний - завершающие и не завершающие. Два состояния в одном классе, если по всем буквам переходят в один класс, иначе создаем новое разбиение. Дробим до стабильного состояния. Полученные классы и переходы - канонический МПДКА

В худшем случае на каждой итерации откалывается лишь $1$ состояние, поэтому есть первый множитель $O(|Q|)$. Внутри цикла так же перебираем $Q$, и для каждого еще перебираем $\Sigma$. Составляем сигнатуру - массив номеров классов, в которые переходит состояние по всем буквам. Потом даем новые номера. Если количество классов не увеличилось - завершаем

### Асимптотика
$O(|\Sigma| \cdot |Q|^2)$ в простой реализации  
$O(|\Sigma| \cdot |Q| \log |Q|)$ в алгоритме Хопкрофта


## 11. Порождающие грамматики. Язык, задаваемый грамматикой. Иерархия Хомского.

**Грамматика (в самом общем виде) -** кортеж $(\Sigma, N, S, P)$, где:

- $\Sigma$ - алфавит терминалов
- $N$ - множество нетерминалов, $\Sigma \cap N = \varnothing$
- $S \in N$ - стартовый нетерминал
- $P$ - конечное множество правил вида $\alpha \to \beta$, где $\alpha \in (\Sigma \cup N)^* \setminus \Sigma^*$, $\beta \in (\Sigma \cup N)^*$

**Отношение выводимости $\vdash$ -** такое что $\forall \eta_1, \eta_2 \in (N \cup \Sigma)^*$  
$$ (\alpha \to \beta) \in P \iff \eta_1 \alpha \eta_2 \vdash_G \eta_1 \beta \eta_2 $$

*Это фактически замена левой части на правую несколько (возможно, ноль) раз*

**Замыкание $\vdash^*$ -** наименьшее рефлексивное транзитивное отношение, содержащее $\vdash$

**Язык, порождаемый грамматикой -** множество всех терминальных строк, выводимых из $S$:
$$ L(G) = \{ w \in \Sigma^* \mid S \vdash^* w \} $$

**Иерархия Хомского -** классификация грамматик по виду правил, каждый следующий класс строго вложен в предыдущий

| Тип | Название | Вид правил | Распознаватель |
| - | - | - | - |
| **0** | Порождающие| Вообще все | МТ |
| **1** | КЗ | $\varphi A \psi \to \varphi \alpha \psi, \alpha \neq \varepsilon^{(*)}$ | Ограниченная МТ |
| **2** | КС | $A \to \alpha$ | МП-автомат |
| **3** | Регулярные | $A \to aB \mid Ba \mid a \mid \varepsilon$ | НКА |

$^{(*)}$ Кроме, возможно, $S \to \varepsilon$  
*$\alpha, \varphi, \psi \in (N \cup \Sigma)^*$*


## 12, 13. Праволинейные грамматики. Связь с автоматами.

**Праволинейная грамматика -** КС-грамматика, где все правила имеют вид $A \to wB$ или $A \to w$

> **Теорема $(\mathbf{AUT = R-LINEAR})$**  
> Класс языков, задаваемых праволинейными грамматиками, совпадает с классом автоматных языков

$\triangle$  
**Построение грамматики по НКА**

- Состояния $Q$ становятся нетерминалами $N$
- Стартовое состояние $q_0$ становится $S$
- Для каждого перехода $(A, w) \to B$ добавляем правило $A \to wB$
- Для каждого $q \in F$ добавляем правило $q \to \varepsilon$

**Построение НКА по грамматике**

- Нетерминалы $N$ становятся состояниями $Q$. Делаем одно завершающее $q_f$
- Для правила $A \to wB$ добавляем переход $(A, w) \to B$
- Для правила $A \to w$ добавляем переход $(A, w) \to q_f$


## 14. КС грамматики и языки. Примеры. Замкнутость.

**КС грамматика -** грамматика $G = (\Sigma, N, S, P)$, в которой каждое правило имеет вид:
$$ A \to \alpha, \quad \text{где } A \in N, \ \alpha \in (\Sigma \cup N)^* $$
Например, ПСП или $\{a^n b^n \}$

Про замкнутость см. билет [25](#25-замкнутость-и-незамкнутость-кс-языков-относительно-теоретико-множественных-операций)


## 15, 16, 17. Нормальная форма Хомского (НФХ). Алгоритм приведения.

**Нормальная форма Хомского -** вид КС-грамматики, где все правила имеют вид:
- $A \to BC$, где $B, C \in N \setminus \{S\}$
- $A \to a$, где $a \in \Sigma$
- $S \to \varepsilon$, *если язык содержит пустое слово*

> **Алгоритм приведения к НФХ**

**1. Удаляем непорождающие символы**

1. $\text{Gen} = \varnothing$
2. Если $(A \to w) \in P$, где $N \cap w = \varnothing$, то добавляем $A$ в $\text{Gen}$
3. Если $A \to X_1 \dots X_k$ и $\forall i: X_i \in (Gen \cup \Sigma)$, добавляем $A$ в $\text{Gen}$
4. Удаляем все нетерминалы не из $\text{Gen}$, и правила их содержащие

**2. Удаляем недостижимые символы**

1. $\text{Reach} = \{S\}$
2. Обходим граф грамматики от $S$, если $A \in \text{Reach}$ и $(A \to \alpha B \beta) \in P$, добавляем $B$ в $\text{Reach}$
3. Удаляем все нетерминалы не из $\text{Reach}$, и правила их содержащие

**3. Обработка старотового нетерминала**

- Пополняем грамматику (вводим новый стартовый символ $S'$ и правило $S' \to S$)

**4. Удаляем смешанные правила**

- Для каждого терминала $a \in \Sigma$ создаем нетерминал $X_a$ и правило $X_a \to a$. Во всех правилах длиной больше единицы, заменяем терминалы $a$ на $X_a$

**5. Удаляем длинные правила (бинаризация)**

- Пока существуют правила $A \to X_1 \dots X_n$, заменяем их на $A \to X_1 B_1$ и $B_1 \to X_2 \dots X_n$

**6. Удаляем эпсилон-правила**

1. $\text{Null} = \varnothing$
2. Если $(A \to \varepsilon) \in P$, то добавляем $A$ в $\text{Null}$
3. Если $A \to \alpha$ и $\forall N \in \alpha: N \in \text{Null}$, добавляем $A$ в $\text{Null}$  
**Тут, если не провести бинаризацию заранее, будут правила вида $A \to X_1 \dots X_k$, из-за чего размер может расти экспоненциально**
1. Для каждого правила, для каждого нетерминала в правой части, лежащего в $\text{Null}$, добавляем в $P$ правило без него
2. Удаляем все правила вида $A \to \varepsilon$, кроме $S' \to \varepsilon$ если есть

**7. Удаляем цепные правила**

1. Строим граф $(N, E)$, где $(A, B) \in E \iff (A \to B) \in P$.
2. 
- Для каждого $A \in N$ имеем $\text{Chain}(A)$ - множество нетерминалов, достижимых по цепным правилам (сам $A$ тоже принадлежит).  
- Для всех пар $(A, B)$, где $B \in \text{Chain}(A)$  
- Для всех нецепных правил $B \to \alpha$ (т.е. $\alpha$ либо терминал, либо $2$ нетерминала)
  Добавляем правило $A \to \alpha$ в $P'$. Затем заменяем $P$ на $P'$
3. Удаляем все цепные правила $A \to B$  

### Асимптотика

Пусть $|G| = \sum_{p \in P} |p|$

1. **Удаление бесполезных (1, 2) - $O(|G|)$**  
  Простой обход графа
2. **Смешанные и длинные правила (3, 4, 5) - $O(|G|)$**  
  Каждое длинное правило разбивается на линейное число коротких. Размер грамматики увеличивается линейно.
3. **Удаление $\varepsilon$-правил (6) - $O(|G'|) = O(|G|)$**  
  Благодаря тому, что правила уже короткие ($\le 2$ нетерминалов), количество правил увеличивается не более чем в константу $(3)$ раз. $|G'|$ - размер после шага $3$
4. **Удаление цепных правил (7) - $O(|N| \cdot |G|)$**  
  В худшем случае, каждый нетерминал в каждом правиле

**Итог:**  
$O(|N| \cdot |G|)$


## 18. Алгоритм Кока–Янгера–Касами (CYK) синтаксического разбора для КС-грамматик.

**Задача разбора -** определить, лежит ли $w \in L(G)$, и, возможно, восстановить дерево вывода

> **Алгоритм CYK**  

Приводим грамматику в НФХ  
Пусть $n = |w|$. Заводим трехмерный массив $D[i][l][A]$ (где $i$ - индекс начала подстроки, $l$ - длина подстроки, $A \in N$), который хранит истину, если из нетерминала $A$ выводима подстрока $w[i : i + l]$

```py
# База
for i in range(0, n):
  for rule in P:
    [A -> a] = rule
    if (w[i] == a):
      D[i][1][A] = True
```

```py
# Переход

# l - длина подстроки
# i - начало подстроки
# k - длина левой части разбиения
for l in range(2, n + 1):
  for i in range(0, n - l + 1):
    for k in range(1, l):
      for rule in P:
        [A -> BC] = rule
        if D[i][k][B] and D[i + k][l - k][C]:
          D[i][l][A] = True
          # Тут можно break, если не нужно знать ВСЕ способы вывода
```

Слово принадлежит языку, если $D[0][n][S] = \text{True}$

### Асимптотика
$O(|w|^3 \cdot |G|)$ - три вложенных цикла по длине слова + перебор правил

Для восстановление вывода нужно хранить не просто $\text{bool}$, а ссылки на то, какое правило $A \to BC$ и какое разбиение $k$ сделали ячейку истинной


## 19. Лемма о накачке для КС языков. Примеры языков, не являющихся КС языками.

> **Лемма о накачке для $\mathbf{CFL}$ языков**  
> Если $L$ - КС-язык, то $\exists p \in \mathbb{N}$, что $\forall w \in L, |w| \ge p$, $\exists$ разбиение $w = xuyvz, |uv| \gt 0, |uyv| \le p$ что:  
> $$ \forall k \ge 0: x u^k y v^k z \in L $$

$\triangle$  
Положим $p = 2^{|N|}$. Тогда, в дереве большего размера, высота будет не менее $|N| + 1$, то есть по Дирихле какой-то нетерминал (некий $A$) повторится. Пусть верхнее вхождение $A$ порождает $uAv$, а нижнее вхождение $A$ порождает $y$. Цикл можно вырезать, или наоборот дублировать сколько угодно раз

**Примеры не КС языков и $w$ для Леммы**
- $L = \{a^n b^n c^n \mid n \ge 1 \}$  
  Берем $w = a^p b^p c^p$
- $L = \{ ww \mid w \in \{a, b\}^* \}$  
  Берем $w = a^p b^p a^p b^p$


## 20. Автоматы с магазинной памятью (МП-автоматы). Различные упрощения определений. Языки, распознаваемые МП-автоматами.

**МП-автомат -** кортеж $(\Sigma, \Gamma, Q, \Delta, q_0, F)$, где:
- $\Sigma$ - входной алфавит
- $\Gamma$ - стековый алфавит $(\Gamma \cap \Sigma = \varnothing)$
- $Q$ - конечное множество состояний
- $q_0 \in Q$ - начальное состояние
- $F \subset Q$ - множество завершающих состояний
- $\Delta \subset Q \times \Sigma^* \times \Gamma^* \times Q \times \Gamma^*$ - множество переходов.
  Переход записывается как: 
  $$ (q, w, \alpha) \to (q', \beta) $$

**Конфигурация -** тройка $(q, w, \alpha) \in S \subset Q \times \Sigma^* \times \Gamma^*$, где $q \in Q$ - состояние, $w$ - оставшийся вход, $\alpha$ - содержимое стека

**Отношение выводимости $\vdash$ -** такое что $\forall u \in \Sigma^*, \gamma \in \Gamma^*$:  

$$ (q, w, \alpha) \to (q', \beta) \in \Delta \iff (q, wu, \gamma \alpha) \vdash (q', u, \gamma \beta) $$

**Замыкание $\vdash^*$ -** наименьшее рефлексивное транзитивное отношение, содержащее $\vdash$

**Язык, задаваемый МП-автоматом (по пустому стеку И принимающему состоянию):**
$$ L(M) = \{ w \mid \exists q_f \in F: (q_0, w, \varepsilon) \vdash^* (q_f, \varepsilon, \varepsilon) \} $$

> **Различные варианты определений МП-автоматов**  
> Любой язык, распознаваемый МП-автоматом, можно задать МП-автоматом, удовлетворяющим любому из ограничений:
> 1. Единственное завершающее состояние.
> 2. На каждом шаге читается не более $1$ буквы, и пишется / убирается со стека не более $1$ буквы, и не одновременно.
> 3. На каждом шаге читается ровно $1$ буква со стека *(требуется символ дна стека $Z$)*
> 4. На каждом шаге стек изменяется ровно на $1$ букву

$\triangle$  
1. Добавляем одно, делаем эпсилон переходы туда
2. Разбиваем на цепочку
3. Переходы $(w : \varepsilon : \varepsilon)$ заменяем на $(w : \varepsilon : Z) + (w : Z : \varepsilon)$
4. С помощью НФГ, см. билет [24](#24-построение-мп-автомата-без-эпсилон-переходов)


## 21, 22. Совпадение классов КС языков и языков МП-автоматов

> **Теорема $(\mathbf{PDA = CFL})$**  
> Класс языков, распознаваемых МП-автоматами, совпадает с классом КС языков

$\triangle$  

**Построение автомата по грамматике (Shift-Reduce)**

В построенном автомате:

- Стек: $\Sigma \cup N$
- Состояния: $\{q_0, q_f\}$
- Переходы $\Delta$:
  - Shift (Перенос):  
    $(q_0, a, \varepsilon) \to (q_0, a)$ для всех $a \in \Sigma$
  - Reduce (Свертка):  
    $(q_0, \varepsilon, \alpha) \to (q_0, A)$ для каждого правила $A \to \alpha \in P$
  - Accept (Завершение): $(q_0, \varepsilon, S) \to (q_f, \varepsilon)$

Автомат моделирует правосторонний вывод в грамматике в обратном порядке (снизу-вверх по дереву)

**Построение грамматики по автомату**

Автомат должен быть приведен к нормальной форме - на каждом шаге размер стека изменяется, причем ровно на $1$.  
Обозначим $A_{pq}$ - нетерминал, переводящий автомат из состояния $p$ в состояние $q$, с сохранением уровня стека, причем в процессе стек может подниматься, но никогда не опускаться ниже изначальной высоты. Любой путь вычисления с пустым итоговым стеком можно разбить на вложенные участки:  
- либо мы просто проходим через промежуточное состояние с той же высотой стека  
- либо мы кладем символ, обрабатываем вложенную часть внутри (поднявшись по стеку), и затем снимаем этот символ

В грамматике будут правила всего $4$ видов:

**1. Старт**  
  Хотим попасть из $q_0$ в любое завершающее:  
  $$ S \to A_{q_0 q_f} \quad \forall q_f \in F $$
**2. База**  
  Ничего не читаем и не трогаем стек:  
  $$ A_{p p} \to \varepsilon \quad \forall p \in Q $$
**3. Разбиение пути**  
  $$ A_{p r} \to A_{p q} A_{q r} \quad \forall \ (p, q, r) \in Q \times Q \times Q $$
**4. Расширение**  
  Cамое важное. Переход между установкой чего-то на стек, нейтральными ходами (по отношению к стеку), и, наконец, убиранием этого со стека можно обозначить как единый переход с конца до начала. Для всех пар переходов вида $(p, a, \varepsilon) \to (r, Z)$ и $(s, b, Z) \to (q, \varepsilon)$ добавляем правило:  
  $$ A_{p q} \to a A_{r s} b $$


## 23. Нормальная форма Грейбах (НФГ) для КС-грамматик.

**Нормальная форма Грейбах -** вид КС-грамматики, где все правила имеют вид

- $A \to a$
- $A \to aB$
- $A \to aBC$ 
- $S \to \varepsilon$, если язык содержит пустое слово

*При переходе к НФГ количество нетерминалов растет квадратично, а размер грамматики - полиномиально*

> **Алгоритм приведения к НФГ**

**1.**

Приводим грамматику к НФХ. Теперь все правила имеют вид $A \to BC$ (ветвления) или $A \to a$ (листовые)

**2.**

Вводим новые нетерминалы вида $A / B$, такие что:
$$ A \vdash_{G_{old}} Bw \iff A/B \vdash_{G_{new}} w $$
Строим правила для новой грамматики:

#### Терминальные правила

Перебираем тройным циклом:
- Для каждого правила ветвления $C \to BD$
- Для каждого листового правила $E \to e$
- Для каждого нетерминала $A$

Добавляем правило $(A / B) \to e (D / E) (A / C)$

#### Стартовый символ

Для каждого $(A \to a) \in P$ добавляем $S \to a (S / A)$

#### Закрытие деления

Для каждого $A \in N$ добавляем $A / A \to \varepsilon$

**3.**

Это порождает много бесполезных нетерминалов, удаляем как описано в первых двух пунктамх билета [17](#15-16-17-нормальная-форма-хомского-нфх-алгоритм-приведения)


## 24. Построение МП-автомата без эпсилон-переходов.

Обычные МП-автоматы могут делать ходы, не читая входной символ, меняя только стек. Это создает проблемы с зацикливанием и сложностью, поэтому нужен автомат, который на каждом шаге обязательно читает $1$ букву.

> **Алгоритм построения МП-автомата без $\varepsilon$-переходов**

Строим грамматику по автомату, приводим ее к НФГ. Затем по грамматике строим автомат так:

- Стек: $N \cup \Sigma$
- Состояния: $\{q_0 \}$ (всего одно, вся работа идет со стеком)
- Переходы $\Delta$:  
  Для каждого правила $(A \to a \alpha) \in P$, можем прочитать $a$, и положить оставшееся на стек, началом наверх (т.е. если $\alpha = B_1 \dots B_n$, то на вершине окажется $B_1$):
  $$ (q_0, a, A) \to (q_0, \alpha) $$

**Начальная конфигурация - $(q_0, w, S)$! (стек непустой)**


## 25. Замкнутость и незамкнутость КС языков относительно теоретико-множественных операций.

> **Замкнутость КС-грамматик относительно операций**  
> Класс языков, задаваемых КС-грамматиками, замкнут относительно:
> - Обьединения
> - Конкатенации
> - Звезды Клини
> - Пересечения с $\mathbf{REG}$ языком

$\triangle$  
- **Обьединение, Конкатенация**  
  Создаем новый стартовый символ $S'$, и правила $S' \to S_1 \mid S_2$ или $S' \to S_1 S_2$ соответственно
- **Звезда Клини**  
  Создаем новый стартовый символ и правило $S' \to S S' \mid \varepsilon$
- **Пересечение с $\mathbf{REG}$ языком**  
  Строится произведение МП-автомата и ДКА. Множество состояний - декартово произведение. ДКА просто повторяет переходы по буквам. Если МП работает со стеком (т.е. читает эпсилон), то ДКА стоит. Произведение МП и ДКА - МП $\implies$ язык КС

> **Отсутствие замкнутости КС языков относительно операций**  
> - Пересечение
> - Дополнение

$\triangle$  
- **Пересечение**  
  Контр-пример $L_1 = \{a^n b^n c^m\}$ $L_2 = \{a^m b^n c^n\}$. $L_1 \cap L_2 = \{a^n b^n c^n\}$, который не является КС по лемме о накачке
- **Дополнение:**  
  Если бы класс был замкнут относительно дополнения, то по закону де Моргана $L_1 \cap L_2 = \overline{\overline{L_1} \cup \overline{L_2}}$ он был бы замкнут и относительно пересечения, что неверно.


## 26, 27, 28. Алгоритм Эрли синтаксического разбора для КС-грамматик.

**Алгоритм Эрли -** алгоритм разбора слова слева направо. Подходит для любой КС-грамматики, даже неоднозначной или с левой рекурсией

**Эрли ситуация -** кортеж $(A \to \alpha \cdot \beta, i, j)$, где:

- $(A \to \alpha \beta) \in P$
- $\cdot \quad$- точка разделитель, $\alpha$ уже разобрали, $\beta$ осталась
- $i$ - индекс начала разбора данного нетерминала $A$
- $j$ - нынешний индекс разбора, индекс разделителя $\cdot$

> **Алгоритм Эрли**  

Пусть $|w| = n$  
Алгоритм хранит $n + 1$ массивов - $D_0, \dots, D_n$. Массив $D_j$ содержит все ситуации, которые актуальны после прочтения $j$ символов входного слова. Последовательно заполняем $D_0, \dots, D_n$. Внутри каждого $D_j$ перебираем ситуации и пытаемся применить к ним три действия, пока множество не перестанет расти:

**1. $\text{Scan}$** - Считывает терминал

Если после точки стоит терминал, ситуация выглядит как $[A \to \alpha \cdot a \beta, i, j]$. Если $w[j]$ реально равен $a$, то добавляем в $D_{j + 1}$ ситуацию $[A \to \alpha a \cdot \beta, i, j + 1]$

**2. $\text{Predict}$** - Считывает нетерминал

Если после точки стоит нетерминал, ситуация выглядит как $[A \to \alpha \cdot B \beta, i, j]$. Перебираем все $P$, и для каждого правила $B \to \gamma$, добавляем $[B \to \cdot \gamma, j, j]$ в $D_j$.

**3. $\text{Complete}$** - Поднимается вверх по рекурсии

Если после точки ничего нет, мы закончили разбор какого-то нетерминала. Ситуация выглядит как $[B \to \gamma \cdot, k, j]$. Нужно найти всех, кому был нужен $B$ в позиции $k$. Перебираем $D_k$, и для каждой ситуации вида $[A \to \alpha \cdot B \beta, i, k]$ сдвигаем точку, т.к. $B$ успешно прочитан, т.е. добавляем $[A \to \alpha B \cdot \beta, i, j]$ в $D_j$

**Если в $D_n$ есть ситуация $[S' \to S \cdot, 0, n]$, слово подходит**

### Асимтпотика

Оценка складывается из размера множеств $D_j$ и стоимости операций.  
Уникальных ситуаций всего $O(n^2)$, т.к. ситуация определяется:  
- правилом, точкой в нем (это все $|G| = O(1)$ по сравнению с длиной слова)
- индексами $i$ и $j$ ($O(n) \cdot O(n)$)

$\text{Scan}$ и $\text{Predict}$ обрабатывают каждую операцию не более $1$ раза, поэтому занимают $O(1) \cdot O(n^2) = O(n^2)$ времени.  
Узкое место - $\text{Complete}$. Она итерируется по $D_k$, поэтому занимает $O(n) \cdot O(|G|) = O(n)$ времени. Всего - $O(n^3)$  

**Итог:** $O(|w|^3)$

В однозначных грамматиках (например, $S \to aSb \mid \varepsilon$) существует единственное дерево разбора, в отличие от неоднозначных (например, $S \to SS | a$). Поэтому, в каждом $D_j$, куда обращается из будущего $\text{Complete}$ с ситуацией $(B \to \gamma \cdot, k)$, ищя ситуацию $(A \to \alpha \cdot B \beta, i)$ чтобы сдвинуть точку, индекс $i$ определяется однозначно. Иначе, часть $\alpha$ разбиралась бы из двух различных $i_1$ и $i_2$. Поэтому, асимптотика будет $O(|w|^2)$


## 29, 30, 31, 32. Все про LR

Пропущено, не нужно учить


## 33. Конечные преобразователи и задаваемые ими преобразования. Теорема Нива.

**Конечный преобразователь -** кортеж $M = (\Sigma, \Gamma, Q, \Delta, q_0, F)$, где:
- $\Sigma$ - входной алфавит
- $\Gamma$ - выходной алфавит
- $Q, q_0, F$ - как в обычном НКА
- $\Delta \subset Q \times \Sigma^* \times Q \times \Gamma^*$ - множество переходов. Переход записывается как:
  $$ (q, u) \to (q', v) $$
Например, шрифт Цезаря (по $a$ пишем $b$, по $b$ пишем $c$..)

**Нормальная форма -** $|u| + |v| = 1$ для всех состояний

**Конечное преобразование -** отображение $\Sigma^* \to \Gamma^*$, задается копателем

**Конфигурация -** тройка $(q, u, v) \in S \subset Q \times \Sigma^* \times \Gamma^*$, где стоим в состоянии $q$, осталось дочитать $u$, а уже написали $v$

**Отношение выводимости $\vdash$ -** такое что $\forall x \in \Sigma^* \ \forall y \in \Gamma^*$:  
$$(q, u) \to (q', v) \in \Delta \iff (q, ux, y) \vdash (q', x, yv) $$

**Замыкание $\vdash^*$ -** наименьшее рефлексивное транзитивное отношение, содержащее $\vdash$

**Гомоморфизм на словах -**  отображение $h: \Sigma^* \to \Gamma^*$, для которого $h(uv) = h(u)h(v)$, а значит $h(\varepsilon) = \varepsilon$

> **Теорема Нива (Nivat)**  
> Пусть $R$ - регулярный язык, $\eta$ и $\phi$ - неудлинняющие гомоморфизмы $(|\phi(w)| \le |w| \ \forall w \in \Sigma^*)$, а $\text{id} \big|_R(w) = w$, если $w \in R$, не определена иначе. Тогда любое КП $\psi: \Sigma^* \to \Gamma^*$ можно представить как комбинацию трех примитивных операций:
> $$ \psi = \eta \circ \text{id}\big|_R \circ \phi^{-1} $$
> *Или, более приятно:*
> $$ \psi = \eta(\phi^{-1} \cap R) $$


$\triangle$  
Дадим каждому ребру автомата свой символ, они составляют алфавит $\Omega$. Тогда пусть $R \subset \Omega^*$ - язык всех валидных путей в автомате, он сам автоматный. Гомоморфизм $\phi(d_i)$ возвращает входную строку, написанную на ребре $d_i \in \Delta$, а $\eta$ - выходную.  
Идея похожа на разложение линейного оператора на ортогональный и самосопряженный


## 34. Ограничение конечного преобразователя на регулярный вход.

> **Теорема**  
> Если $\phi$ - копатель, $R$ - регулярный язык, то $\phi \big|_R$ тоже копатель

$\triangle$  
Так как $\phi \big|_R = \phi \circ \text{id}_R$, по билету [35](#35-замкнутость-конечных-преобразований-относительно-композиции) получаем требуемое


## 35. Замкнутость конечных преобразований относительно композиции

> **Теорема**  
> Композиция конечных преобразований - конечное преобразование

$\triangle$  
Пусть $M_1$ реализует $\tau_1$, а $M_2$ реализует $\tau_2$.
Чтобы построить автомат для композиции, нам нужно скормить выход $M_1$ на вход $M_2$

Приводим автоматы к нормальной форме, но с допущением эпсилон переходом (либо читаем, либо пишем, либо ничего). Строим декартово произведение автоматов: $Q' = Q_1 \times Q_2$

Переходы:
- **Если $M_1$ читает**  
  Сдвигаем только первый. Переходу $(q_1, a) \to (p_1, \varepsilon)$ в $M_1$ сопоставляем:  
  $$ ((q_1, q_2), a) \to ((p_1, q_2), \varepsilon) $$
- **Если $M_1$ пишет и $M_2$ читает**  
  Если буква совпадает, то она сразу нейтрализуется вторым автоматом. Паре переходов $(q_1, \varepsilon) \to (p_1, a)$ и $(q_2, a) \to (p_2, \varepsilon)$ в $M_1$ и $M_2$ соответственно сопоставляем:  
  $$ ((q_1, q_2), \varepsilon) \to ((p_1, p_2), \varepsilon) $$
- **Если $M_2$ пишет**  
  Сдвигаем только второй. Переходу $(q_2, \varepsilon) \to (p_2, a)$ сопоставляем:  
  $$ ((q_1, q_2), \varepsilon) \to ((q_1, p_2), a) $$


## 36. Замкнутость класса автоматных языков относительно конечных преобразований

> **Теорема об образе $\mathbf{REG}$ языка**  
> $L \subset \Sigma^*$ - регулярный, $\tau$ - копатель, то $\tau(L) = \{ v \mid \exists u \in L: (u, v) \in \tau \}$ тоже регулярный

$\triangle$  
По теореме Нива:  
$$ \tau = \eta \circ \text{id} \big|_R \circ \phi^{-1} $$
Класс $\mathbf{REG}$ замкнут относительно гомоморфизма (и обратного тоже), и относительно пересечения (вторая композиция - пересечение с $R$) $\implies \tau(L)$ регулярный


## 37. Замкнутость класса КС языков относительно конечных преобразований

> **Теорема об образе $\mathbf{CFL}$ языка**  
> $L \subset \Sigma^*$ - КС язык, $\tau$ - копатель, то $\tau(L) = \{ v \mid \exists u \in L: (u, v) \in \tau \}$ тоже КС язык

$\triangle$  \
По теореме Нива:  
$$ \tau = \eta \circ \text{id} \big|_R \circ \phi^{-1} $$
Класс $\mathbf{CFL}$ замкнут относительно гомоморфизма (и обратного тоже), и относительно пересечения с регулярным языком (вторая композиция - пересечение с $R$) $\implies \tau(L)$ - КС язык


## 38. Лемма о накачке для конечных преобразований. Примеры соответствий, не задаваемых конечными преобразованиями.

> **Лемма о накачке для копателей**  
> Если $\tau$ - копатель, то $\exists p \in \mathbb{N}$, что $\forall (u, v) \in \tau, |u| + |v| \ge p$, существует разбиение $(u, v) = (u_1 u_2 u_3, v_1 v_2 v_3)$, такое что:
> - $|u_1 u_2| + |v_1 v_2| \le p$
> - $|u_2| + |v_2| \gt 0$
> 
> Тогда:
> $$ \forall k \ge 0: (u_1 u_2^k u_3, \ v_1 v_2^k v_3) \in \tau $$

$\triangle$  
Аналогично билету [9](#9-лемма-о-накачке-для-автоматных-языков-примеры-неавтоматных-языков) для $\mathbf{REG}$ языков, положим $p = |u| + |v|$, т.к. в нормальной форме длина пути такая

**Примеры соответствий, не задаваемых копателями и $w$ для Леммы**  
- $R = \{ (w, w^R) \mid w \in \{a, b\}^* \}$  
  Берем $(u, v) = (a^p b^p, b^p a^p)$
- $R = \{ ww \mid w \in \{a, b\}^* \}$  
  Берем $(u, v) = (a^p b, a^p b a^p b)$

---
